From 3813166188e2513008f38043df074de8cb816e6b Mon Sep 17 00:00:00 2001
From: Christian Schuster <christian.schuster@systec-electronic.com>
Date: Mon, 14 Oct 2024 13:32:59 +0200
Subject: [PATCH 3/3] tty: serial: 8250: Add quirk handling for some sysworxx
 modules

Signed-off-by: Andreas Dinter <andreas.dinter@systec-electronic.com>
Signed-off-by: Christian Schuster <christian.schuster@systec-electronic.com>
---
 drivers/tty/serial/8250/8250_omap.c | 69 ++++++++++++++++++++++++++++-
 1 file changed, 67 insertions(+), 2 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index a2125dc8ad47..68b0fda6c882 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -118,15 +118,19 @@
 /* RX FIFO occupancy indicator */
 #define UART_OMAP_RX_LVL		0x19
 
+/* Enhanced Control Register (0x90 >> 2) */
+#define UART_ECR 0x24
+#define UART_ECR_RX_EN (1 << 3)
+
 /* Timeout low and High */
 #define UART_OMAP_TO_L                 0x26
 #define UART_OMAP_TO_H                 0x27
 
-/*
+	/*
  * Copy of the genpd flags for the console.
  * Only used if console suspend is disabled
  */
-static unsigned int genpd_flags_console;
+	static unsigned int genpd_flags_console;
 
 struct omap8250_priv {
 	void __iomem *membase;
@@ -1403,6 +1407,62 @@ static int omap8250_em485_config(struct uart_port *port,
 	return ret;
 }
 
+void omap8250_em485_start_tx_systec_quirk(struct uart_8250_port *up)
+{
+	unsigned char mcr = serial8250_in_MCR(up);
+
+	if (!(up->port.rs485.flags & SER_RS485_RX_DURING_TX)) {
+		// see serial8250_stop_rx in 8250_port.c
+		serial8250_rpm_get(up);
+
+		// disable UART receiver during tx to avoid local echo caused by
+		// ISL81387
+		int ecr = serial_in(up, UART_ECR);
+		ecr &= ~UART_ECR_RX_EN;
+		serial_out(up, UART_ECR, ecr);
+
+		up->ier &= ~(UART_IER_RLSI | UART_IER_RDI);
+		up->port.read_status_mask &= ~UART_LSR_DR;
+		serial_out(up, UART_IER, up->ier);
+
+		serial8250_rpm_put(up);
+	}
+
+	if (up->port.rs485.flags & SER_RS485_RTS_ON_SEND)
+		mcr |= UART_MCR_RTS;
+	else
+		mcr &= ~UART_MCR_RTS;
+	serial8250_out_MCR(up, mcr);
+}
+
+void omap8250_em485_stop_tx_systec_quirk(struct uart_8250_port *p)
+{
+	unsigned char mcr = serial8250_in_MCR(p);
+
+	if (p->port.rs485.flags & SER_RS485_RTS_AFTER_SEND)
+		mcr |= UART_MCR_RTS;
+	else
+		mcr &= ~UART_MCR_RTS;
+	serial8250_out_MCR(p, mcr);
+
+	/*
+	 * Empty the RX FIFO, we are not interested in anything
+	 * received during the half-duplex transmission.
+	 * Enable previously disabled RX interrupts.
+	 */
+	if (!(p->port.rs485.flags & SER_RS485_RX_DURING_TX)) {
+		serial8250_clear_and_reinit_fifos(p);
+
+		// re-enable UART receiver
+		int ecr = serial_in(p, UART_ECR);
+		ecr |= UART_ECR_RX_EN;
+		serial_out(p, UART_ECR, ecr);
+
+		p->ier |= UART_IER_RLSI | UART_IER_RDI;
+		serial_port_out(&p->port, UART_IER, p->ier);
+	}
+}
+
 static void ti_sermode_worker(struct work_struct *work)
 {
 	struct omap8250_priv *priv = container_of(work, struct omap8250_priv, sermode_worker);
@@ -1566,6 +1626,11 @@ static int omap8250_probe(struct platform_device *pdev)
 			 DEFAULT_CLK_SPEED);
 	}
 
+	if (of_property_present(np, "systec,rs485-half-duplex-stop-rx")) {
+		up.rs485_start_tx = omap8250_em485_start_tx_systec_quirk;
+		up.rs485_stop_tx = omap8250_em485_stop_tx_systec_quirk;
+	}
+
 	priv->membase = membase;
 	priv->line = -ENODEV;
 	priv->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;
-- 
2.46.2

