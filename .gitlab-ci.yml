---
default:
  image: ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/yocto-builder:latest
  tags: [docker, yocto]

variables:
  FF_DISABLE_UMASK_FOR_DOCKER_EXECUTOR: true
  GIT_SUBMODULE_STRATEGY: recursive
  GIT_DEPTH: 0
  # don't clean Yocto build/tmp directory per default
  GIT_CLEAN_FLAGS: -ffdx -e build/

stages:
  - build
  - deploy

.common_before_script_rauc: &common_before_script_rauc
  before_script:
    - echo 'DL_DIR="/cache/downloads"' >> ./build/conf/local.conf
    - echo 'SSTATE_DIR="/cache/sstate-cache"' >> ./build/conf/local.conf
    - cp -v $RAUC_CRT sources/meta-sysworxx/keys/rauc.crt
    - cp -v $RAUC_KEY sources/meta-sysworxx/keys/rauc.key
    - export GIT_DESCRIBE=$(git describe --tags)

.build-image-with-cve-check:
  extends: .common_before_script_rauc
  stage: build
  allow_failure:
    exit_codes: [42]  # Soft-fail if unpatched CVEs are found
  script:
    - cd build/
    - . conf/setenv
    - bitbake ${BITBAKE_TARGET} -r conf/cve_check.conf

    # Copy image artifact
    - |
      cp deploy-ti/images/sysworxx/${BITBAKE_TARGET}-sysworxx.rootfs.wic.xz \
      ../${IMAGE_ARTIFACT_PREFIX}-${BITBAKE_TARGET}-sysworxx-${GIT_DESCRIBE}.rootfs.wic.xz

    - echo "Parsing CVE summary..."
    - |
      jq '{
        version,
        package: [.package[] |
          . as $pkg |
          {
            name,
            layer,
            version,
            products,
            issue: ($pkg.issue | map(select(.status != "Patched" and .status != "Ignored")))
          } | select(.issue | length > 0)
        ]
      }' tmp/log/cve/cve-summary.json > ../cve-summary-unpatched.json

    - |
      UNPATCHED=$(jq '.package | length' ../cve-summary-unpatched.json)

      if [ "$UNPATCHED" -gt 0 ]; then
        echo "üö® WARNING: Found $UNPATCHED packages with unpatched CVEs."
        jq -r '.package[] | "\(.name) \(.version): \(.issue | length) unpatched issue(s)"' ../cve-summary-unpatched.json
        echo "‚ùó Treating as warning only (exit 42)"
        exit 42
      else
        echo "‚úÖ No unpatched CVEs found."
      fi
  cache:
    key: "cache-${CI_COMMIT_REF_SLUG}"
    paths:
      - tmp/log/cve/cve-summary.json
  artifacts:
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA"
    when: always
    expire_in: 1 week
    paths:
      - "${IMAGE_ARTIFACT_PREFIX}-*.wic.xz"
      - "cve-summary-unpatched.json"


.rules-dev: &rules-dev
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "schedule" || $CI_PIPELINE_SOURCE == "web"'
      variables:
        RAUC_CRT: $RAUC_CRT_DEFAULT
        RAUC_KEY: $RAUC_KEY_DEFAULT

.rules-release: &rules-release
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        RAUC_CRT: $RAUC_CRT_RELEASE
        RAUC_KEY: $RAUC_KEY_RELEASE

sysworxx-image-default-dev:
  extends: .build-image-with-cve-check
  <<: *rules-dev
  variables:
    BITBAKE_TARGET: sysworxx-image-default
    IMAGE_ARTIFACT_PREFIX: E004494

sysworxx-image-default-release:
  extends: .build-image-with-cve-check
  <<: *rules-release
  variables:
    BITBAKE_TARGET: sysworxx-image-default
    IMAGE_ARTIFACT_PREFIX: E004494

sysworxx-image-browser-hmi-dev:
  extends: .build-image-with-cve-check
  <<: *rules-dev
  variables:
    BITBAKE_TARGET: sysworxx-image-browser-hmi
    IMAGE_ARTIFACT_PREFIX: E004495

sysworxx-image-browser-hmi-release:
  extends: .build-image-with-cve-check
  <<: *rules-release
  variables:
    BITBAKE_TARGET: sysworxx-image-browser-hmi
    IMAGE_ARTIFACT_PREFIX: E004495

.sysworxx-bundle-default:
  extends: .common_before_script_rauc
  tags:
    - seccomp_unconfined
  stage: build
  script: |
    cd build/
    . conf/setenv
    bitbake sysworxx-bundle-default
    cp deploy-ti/images/sysworxx/sysworxx-bundle-default-sysworxx.raucb \
       ../E004493-sysworxx-bundle-default-sysworxx-${GIT_DESCRIBE}.raucb
  artifacts:
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA"
    when: on_success
    expire_in: 1 week
    paths:
      - "E004493-*.raucb"

sysworxx-bundle-default-dev:
  extends: .sysworxx-bundle-default
  <<: *rules-dev

sysworxx-bundle-default-release:
  extends: .sysworxx-bundle-default
  <<: *rules-release

.emmc-installer:
  extends: .common_before_script_rauc
  stage: build
  script: |
    cd build/
    . conf/setenv
    bitbake sysworxx-bundle-default
    ../emmc-installer/build.sh
    cp ./sysworxx-image-default-emmc-installer.sh \
       ../E004481-sysworxx-image-default-emmc-installer-${GIT_DESCRIBE}.sh
  artifacts:
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA"
    when: on_success
    expire_in: 1 week
    paths:
      - E004481-*.sh

emmc-installer-dev:
  extends: .emmc-installer
  <<: *rules-dev

emmc-installer-release:
  extends: .emmc-installer
  <<: *rules-release

bare-repo-release:
  stage: deploy
  image:
    name: alpine
  variables:
    GIT_STRATEGY: clone
    GIT_CHECKOUT: "false"
  before_script:
    - |
      mkdir -p /cache/apk/
      apk add --cache-dir /cache/apk/ git
  script:
    - |
      describe="${CI_COMMIT_TAG:-${CI_COMMIT_BRANCH}}-${CI_COMMIT_SHORT_SHA}"
      gitc="git -C "${CI_PROJECT_NAME}.git""
      project_url=$(git -C .git/ remote -v | grep fetch | awk '{print $2}')
      rm -r .git

      git clone --bare ${project_url} "${CI_PROJECT_NAME}.git"

      if [[ -n "${CI_COMMIT_BRANCH}" && "${CI_COMMIT_BRANCH}" != "${CI_DEFAULT_BRANCH}" ]]; then
        $gitc branch | grep -v -e "${CI_DEFAULT_BRANCH}" -e ${CI_COMMIT_BRANCH} | xargs $gitc branch -D
      else
        $gitc branch | grep -v -e "${CI_DEFAULT_BRANCH}" | xargs $gitc branch -D
      fi
      $gitc gc
      $gitc remote remove origin

      echo branches:
      $gitc branch
      echo tags:
      $gitc tag

      tar jcfv "${CI_PROJECT_NAME}-${describe}.tar.bz2" "${CI_PROJECT_NAME}.git"
      tar zcfv "${CI_PROJECT_NAME}-${describe}.tar.gz" "${CI_PROJECT_NAME}.git"
  artifacts:
    paths:
      - "./${CI_PROJECT_NAME}-*.tar.*"
  only:
    refs:
      - master
      - web
      - merge_requests
      - tags
